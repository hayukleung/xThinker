---
title: inline-in-cpp
date: 2012-09-02 22:13:10
tags: c
---

[原文地址](http://www.cnblogs.com/liangxiaxu/archive/2012/09/02/2667395.html)

与宏的比较
内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如：
```
#define TABLE_COMP(x) ((x)>0?(x):0)
```
就定义了一个宏。
为什么要使用宏呢？因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。
但是宏也有很多的不尽人意的地方。
1、宏不能访问对象的私有成员。
2、宏的定义很容易产生二意性。
我们举个例子：
```
#define TABLE_MULTI(x) (x*x)
```
我们用一个数字去调用它：
```
TABLE_MULTI(10);
```
这样看上去没有什么错误，结果返回100是正确的，但是如果我们用：
```
TABLE_MULTI(10+10);
```
去调用的话，我们期望的结果是400，而宏的调用结果是(10+10*10+10)，结果是120，这显然不是我们要得到的结果。避免这些错误的方法，一是给宏的参数都加上括号：
```
#define TABLE_MULTI(x) ((x)*(x))
```
这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用：
```
TABLE_MULTI(a++);
```
调用它，他们本意是希望得到(a+1)*(a+1)的结果，而实际上呢？我们可以看看宏的展开结果：(a++)*(a++)，如果a的值是4，我们得到的结果是4*4 = 16，a = 6。而我们期望的结果是5*5=25，这又出现了问题。
事实上，在一些C的库函数中也有这些问题。例如：
```
Toupper(*pChar++);
```
就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。
我们可以看到宏有一些难以避免的问题，怎么解决呢？
下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。
内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。
我们可以用inline来定义内联函数，不过，任何在类的说明部分定义的函数都会被自动的认为是内联函数。
下面我们来介绍一下内联函数的用法。
内联函数必须是和函数体申明在一起，才有效。像这样的申明：
```
inline Tablefunction(int I);
```
是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体：
```
inline tablefunction(int I) {return I*I};
```
这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。
我们也可以将定义在类的外部的函数定义为内联函数，比如：
```
class TableClass
{
private:
    int I,j;
public:
    int add() { return I+j;};
    inline int dec() { return I-j;}
    int GetNum(); 
}

inline int tableclass::GetNum()
{
    return I;
}
```
上面申明的三个函数都是内联函数。在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。
内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。
对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。
```
class sample
{
private:
    int nTest;
public:
    int readtest() { return nTest;}
    void settest(int I) {nTest=I;}
}
```
当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。
使用内联函数应注意的事项
内联函数具有一般函数的特性，它与一般函数所不同之处只在于函数调用的处理。一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。在使用内联函数时，应注意如下几点：
1.在内联函数内不允许用循环语句和开关语句。
如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数（自己调用自己的函数）是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。
2.内联函数的定义必须出现在内联函数第一次被调用之前。
3.本栏目讲到的类结构中所有在类说明内部定义的函数是内联函数。